// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'visual_director_input.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

VisualDirectorInput _$VisualDirectorInputFromJson(Map<String, dynamic> json) {
  return _VisualDirectorInput.fromJson(json);
}

/// @nodoc
mixin _$VisualDirectorInput {
  FocusPoint get focusPoint => throw _privateConstructorUsedError;
  SceneContext get sceneContext => throw _privateConstructorUsedError;
  CharacterVisuals get characters => throw _privateConstructorUsedError;
  ComfyUIModelPreset get modelPreset => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $VisualDirectorInputCopyWith<VisualDirectorInput> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VisualDirectorInputCopyWith<$Res> {
  factory $VisualDirectorInputCopyWith(
          VisualDirectorInput value, $Res Function(VisualDirectorInput) then) =
      _$VisualDirectorInputCopyWithImpl<$Res, VisualDirectorInput>;
  @useResult
  $Res call(
      {FocusPoint focusPoint,
      SceneContext sceneContext,
      CharacterVisuals characters,
      ComfyUIModelPreset modelPreset});

  $FocusPointCopyWith<$Res> get focusPoint;
  $SceneContextCopyWith<$Res> get sceneContext;
  $CharacterVisualsCopyWith<$Res> get characters;
  $ComfyUIModelPresetCopyWith<$Res> get modelPreset;
}

/// @nodoc
class _$VisualDirectorInputCopyWithImpl<$Res, $Val extends VisualDirectorInput>
    implements $VisualDirectorInputCopyWith<$Res> {
  _$VisualDirectorInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? focusPoint = null,
    Object? sceneContext = null,
    Object? characters = null,
    Object? modelPreset = null,
  }) {
    return _then(_value.copyWith(
      focusPoint: null == focusPoint
          ? _value.focusPoint
          : focusPoint // ignore: cast_nullable_to_non_nullable
              as FocusPoint,
      sceneContext: null == sceneContext
          ? _value.sceneContext
          : sceneContext // ignore: cast_nullable_to_non_nullable
              as SceneContext,
      characters: null == characters
          ? _value.characters
          : characters // ignore: cast_nullable_to_non_nullable
              as CharacterVisuals,
      modelPreset: null == modelPreset
          ? _value.modelPreset
          : modelPreset // ignore: cast_nullable_to_non_nullable
              as ComfyUIModelPreset,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $FocusPointCopyWith<$Res> get focusPoint {
    return $FocusPointCopyWith<$Res>(_value.focusPoint, (value) {
      return _then(_value.copyWith(focusPoint: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $SceneContextCopyWith<$Res> get sceneContext {
    return $SceneContextCopyWith<$Res>(_value.sceneContext, (value) {
      return _then(_value.copyWith(sceneContext: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CharacterVisualsCopyWith<$Res> get characters {
    return $CharacterVisualsCopyWith<$Res>(_value.characters, (value) {
      return _then(_value.copyWith(characters: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ComfyUIModelPresetCopyWith<$Res> get modelPreset {
    return $ComfyUIModelPresetCopyWith<$Res>(_value.modelPreset, (value) {
      return _then(_value.copyWith(modelPreset: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$VisualDirectorInputImplCopyWith<$Res>
    implements $VisualDirectorInputCopyWith<$Res> {
  factory _$$VisualDirectorInputImplCopyWith(_$VisualDirectorInputImpl value,
          $Res Function(_$VisualDirectorInputImpl) then) =
      __$$VisualDirectorInputImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {FocusPoint focusPoint,
      SceneContext sceneContext,
      CharacterVisuals characters,
      ComfyUIModelPreset modelPreset});

  @override
  $FocusPointCopyWith<$Res> get focusPoint;
  @override
  $SceneContextCopyWith<$Res> get sceneContext;
  @override
  $CharacterVisualsCopyWith<$Res> get characters;
  @override
  $ComfyUIModelPresetCopyWith<$Res> get modelPreset;
}

/// @nodoc
class __$$VisualDirectorInputImplCopyWithImpl<$Res>
    extends _$VisualDirectorInputCopyWithImpl<$Res, _$VisualDirectorInputImpl>
    implements _$$VisualDirectorInputImplCopyWith<$Res> {
  __$$VisualDirectorInputImplCopyWithImpl(_$VisualDirectorInputImpl _value,
      $Res Function(_$VisualDirectorInputImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? focusPoint = null,
    Object? sceneContext = null,
    Object? characters = null,
    Object? modelPreset = null,
  }) {
    return _then(_$VisualDirectorInputImpl(
      focusPoint: null == focusPoint
          ? _value.focusPoint
          : focusPoint // ignore: cast_nullable_to_non_nullable
              as FocusPoint,
      sceneContext: null == sceneContext
          ? _value.sceneContext
          : sceneContext // ignore: cast_nullable_to_non_nullable
              as SceneContext,
      characters: null == characters
          ? _value.characters
          : characters // ignore: cast_nullable_to_non_nullable
              as CharacterVisuals,
      modelPreset: null == modelPreset
          ? _value.modelPreset
          : modelPreset // ignore: cast_nullable_to_non_nullable
              as ComfyUIModelPreset,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$VisualDirectorInputImpl implements _VisualDirectorInput {
  const _$VisualDirectorInputImpl(
      {required this.focusPoint,
      required this.sceneContext,
      required this.characters,
      required this.modelPreset});

  factory _$VisualDirectorInputImpl.fromJson(Map<String, dynamic> json) =>
      _$$VisualDirectorInputImplFromJson(json);

  @override
  final FocusPoint focusPoint;
  @override
  final SceneContext sceneContext;
  @override
  final CharacterVisuals characters;
  @override
  final ComfyUIModelPreset modelPreset;

  @override
  String toString() {
    return 'VisualDirectorInput(focusPoint: $focusPoint, sceneContext: $sceneContext, characters: $characters, modelPreset: $modelPreset)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$VisualDirectorInputImpl &&
            (identical(other.focusPoint, focusPoint) ||
                other.focusPoint == focusPoint) &&
            (identical(other.sceneContext, sceneContext) ||
                other.sceneContext == sceneContext) &&
            (identical(other.characters, characters) ||
                other.characters == characters) &&
            (identical(other.modelPreset, modelPreset) ||
                other.modelPreset == modelPreset));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, focusPoint, sceneContext, characters, modelPreset);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$VisualDirectorInputImplCopyWith<_$VisualDirectorInputImpl> get copyWith =>
      __$$VisualDirectorInputImplCopyWithImpl<_$VisualDirectorInputImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$VisualDirectorInputImplToJson(
      this,
    );
  }
}

abstract class _VisualDirectorInput implements VisualDirectorInput {
  const factory _VisualDirectorInput(
          {required final FocusPoint focusPoint,
          required final SceneContext sceneContext,
          required final CharacterVisuals characters,
          required final ComfyUIModelPreset modelPreset}) =
      _$VisualDirectorInputImpl;

  factory _VisualDirectorInput.fromJson(Map<String, dynamic> json) =
      _$VisualDirectorInputImpl.fromJson;

  @override
  FocusPoint get focusPoint;
  @override
  SceneContext get sceneContext;
  @override
  CharacterVisuals get characters;
  @override
  ComfyUIModelPreset get modelPreset;
  @override
  @JsonKey(ignore: true)
  _$$VisualDirectorInputImplCopyWith<_$VisualDirectorInputImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

FocusPoint _$FocusPointFromJson(Map<String, dynamic> json) {
  return _FocusPoint.fromJson(json);
}

/// @nodoc
mixin _$FocusPoint {
  UserAction get userAction => throw _privateConstructorUsedError;
  PartnerReaction get partnerReaction => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FocusPointCopyWith<FocusPoint> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FocusPointCopyWith<$Res> {
  factory $FocusPointCopyWith(
          FocusPoint value, $Res Function(FocusPoint) then) =
      _$FocusPointCopyWithImpl<$Res, FocusPoint>;
  @useResult
  $Res call({UserAction userAction, PartnerReaction partnerReaction});

  $UserActionCopyWith<$Res> get userAction;
  $PartnerReactionCopyWith<$Res> get partnerReaction;
}

/// @nodoc
class _$FocusPointCopyWithImpl<$Res, $Val extends FocusPoint>
    implements $FocusPointCopyWith<$Res> {
  _$FocusPointCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? userAction = null,
    Object? partnerReaction = null,
  }) {
    return _then(_value.copyWith(
      userAction: null == userAction
          ? _value.userAction
          : userAction // ignore: cast_nullable_to_non_nullable
              as UserAction,
      partnerReaction: null == partnerReaction
          ? _value.partnerReaction
          : partnerReaction // ignore: cast_nullable_to_non_nullable
              as PartnerReaction,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $UserActionCopyWith<$Res> get userAction {
    return $UserActionCopyWith<$Res>(_value.userAction, (value) {
      return _then(_value.copyWith(userAction: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PartnerReactionCopyWith<$Res> get partnerReaction {
    return $PartnerReactionCopyWith<$Res>(_value.partnerReaction, (value) {
      return _then(_value.copyWith(partnerReaction: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$FocusPointImplCopyWith<$Res>
    implements $FocusPointCopyWith<$Res> {
  factory _$$FocusPointImplCopyWith(
          _$FocusPointImpl value, $Res Function(_$FocusPointImpl) then) =
      __$$FocusPointImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({UserAction userAction, PartnerReaction partnerReaction});

  @override
  $UserActionCopyWith<$Res> get userAction;
  @override
  $PartnerReactionCopyWith<$Res> get partnerReaction;
}

/// @nodoc
class __$$FocusPointImplCopyWithImpl<$Res>
    extends _$FocusPointCopyWithImpl<$Res, _$FocusPointImpl>
    implements _$$FocusPointImplCopyWith<$Res> {
  __$$FocusPointImplCopyWithImpl(
      _$FocusPointImpl _value, $Res Function(_$FocusPointImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? userAction = null,
    Object? partnerReaction = null,
  }) {
    return _then(_$FocusPointImpl(
      userAction: null == userAction
          ? _value.userAction
          : userAction // ignore: cast_nullable_to_non_nullable
              as UserAction,
      partnerReaction: null == partnerReaction
          ? _value.partnerReaction
          : partnerReaction // ignore: cast_nullable_to_non_nullable
              as PartnerReaction,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FocusPointImpl implements _FocusPoint {
  const _$FocusPointImpl(
      {required this.userAction, required this.partnerReaction});

  factory _$FocusPointImpl.fromJson(Map<String, dynamic> json) =>
      _$$FocusPointImplFromJson(json);

  @override
  final UserAction userAction;
  @override
  final PartnerReaction partnerReaction;

  @override
  String toString() {
    return 'FocusPoint(userAction: $userAction, partnerReaction: $partnerReaction)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FocusPointImpl &&
            (identical(other.userAction, userAction) ||
                other.userAction == userAction) &&
            (identical(other.partnerReaction, partnerReaction) ||
                other.partnerReaction == partnerReaction));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, userAction, partnerReaction);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FocusPointImplCopyWith<_$FocusPointImpl> get copyWith =>
      __$$FocusPointImplCopyWithImpl<_$FocusPointImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FocusPointImplToJson(
      this,
    );
  }
}

abstract class _FocusPoint implements FocusPoint {
  const factory _FocusPoint(
      {required final UserAction userAction,
      required final PartnerReaction partnerReaction}) = _$FocusPointImpl;

  factory _FocusPoint.fromJson(Map<String, dynamic> json) =
      _$FocusPointImpl.fromJson;

  @override
  UserAction get userAction;
  @override
  PartnerReaction get partnerReaction;
  @override
  @JsonKey(ignore: true)
  _$$FocusPointImplCopyWith<_$FocusPointImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

UserAction _$UserActionFromJson(Map<String, dynamic> json) {
  return _UserAction.fromJson(json);
}

/// @nodoc
mixin _$UserAction {
  String get action => throw _privateConstructorUsedError;
  String get sdxlTags => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $UserActionCopyWith<UserAction> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserActionCopyWith<$Res> {
  factory $UserActionCopyWith(
          UserAction value, $Res Function(UserAction) then) =
      _$UserActionCopyWithImpl<$Res, UserAction>;
  @useResult
  $Res call({String action, String sdxlTags});
}

/// @nodoc
class _$UserActionCopyWithImpl<$Res, $Val extends UserAction>
    implements $UserActionCopyWith<$Res> {
  _$UserActionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? action = null,
    Object? sdxlTags = null,
  }) {
    return _then(_value.copyWith(
      action: null == action
          ? _value.action
          : action // ignore: cast_nullable_to_non_nullable
              as String,
      sdxlTags: null == sdxlTags
          ? _value.sdxlTags
          : sdxlTags // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$UserActionImplCopyWith<$Res>
    implements $UserActionCopyWith<$Res> {
  factory _$$UserActionImplCopyWith(
          _$UserActionImpl value, $Res Function(_$UserActionImpl) then) =
      __$$UserActionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String action, String sdxlTags});
}

/// @nodoc
class __$$UserActionImplCopyWithImpl<$Res>
    extends _$UserActionCopyWithImpl<$Res, _$UserActionImpl>
    implements _$$UserActionImplCopyWith<$Res> {
  __$$UserActionImplCopyWithImpl(
      _$UserActionImpl _value, $Res Function(_$UserActionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? action = null,
    Object? sdxlTags = null,
  }) {
    return _then(_$UserActionImpl(
      action: null == action
          ? _value.action
          : action // ignore: cast_nullable_to_non_nullable
              as String,
      sdxlTags: null == sdxlTags
          ? _value.sdxlTags
          : sdxlTags // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UserActionImpl implements _UserAction {
  const _$UserActionImpl({required this.action, required this.sdxlTags});

  factory _$UserActionImpl.fromJson(Map<String, dynamic> json) =>
      _$$UserActionImplFromJson(json);

  @override
  final String action;
  @override
  final String sdxlTags;

  @override
  String toString() {
    return 'UserAction(action: $action, sdxlTags: $sdxlTags)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserActionImpl &&
            (identical(other.action, action) || other.action == action) &&
            (identical(other.sdxlTags, sdxlTags) ||
                other.sdxlTags == sdxlTags));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, action, sdxlTags);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserActionImplCopyWith<_$UserActionImpl> get copyWith =>
      __$$UserActionImplCopyWithImpl<_$UserActionImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$UserActionImplToJson(
      this,
    );
  }
}

abstract class _UserAction implements UserAction {
  const factory _UserAction(
      {required final String action,
      required final String sdxlTags}) = _$UserActionImpl;

  factory _UserAction.fromJson(Map<String, dynamic> json) =
      _$UserActionImpl.fromJson;

  @override
  String get action;
  @override
  String get sdxlTags;
  @override
  @JsonKey(ignore: true)
  _$$UserActionImplCopyWith<_$UserActionImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

PartnerReaction _$PartnerReactionFromJson(Map<String, dynamic> json) {
  return _PartnerReaction.fromJson(json);
}

/// @nodoc
mixin _$PartnerReaction {
  String get action => throw _privateConstructorUsedError;
  List<String> get physicalState => throw _privateConstructorUsedError;
  String get mood => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PartnerReactionCopyWith<PartnerReaction> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PartnerReactionCopyWith<$Res> {
  factory $PartnerReactionCopyWith(
          PartnerReaction value, $Res Function(PartnerReaction) then) =
      _$PartnerReactionCopyWithImpl<$Res, PartnerReaction>;
  @useResult
  $Res call({String action, List<String> physicalState, String mood});
}

/// @nodoc
class _$PartnerReactionCopyWithImpl<$Res, $Val extends PartnerReaction>
    implements $PartnerReactionCopyWith<$Res> {
  _$PartnerReactionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? action = null,
    Object? physicalState = null,
    Object? mood = null,
  }) {
    return _then(_value.copyWith(
      action: null == action
          ? _value.action
          : action // ignore: cast_nullable_to_non_nullable
              as String,
      physicalState: null == physicalState
          ? _value.physicalState
          : physicalState // ignore: cast_nullable_to_non_nullable
              as List<String>,
      mood: null == mood
          ? _value.mood
          : mood // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$PartnerReactionImplCopyWith<$Res>
    implements $PartnerReactionCopyWith<$Res> {
  factory _$$PartnerReactionImplCopyWith(_$PartnerReactionImpl value,
          $Res Function(_$PartnerReactionImpl) then) =
      __$$PartnerReactionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String action, List<String> physicalState, String mood});
}

/// @nodoc
class __$$PartnerReactionImplCopyWithImpl<$Res>
    extends _$PartnerReactionCopyWithImpl<$Res, _$PartnerReactionImpl>
    implements _$$PartnerReactionImplCopyWith<$Res> {
  __$$PartnerReactionImplCopyWithImpl(
      _$PartnerReactionImpl _value, $Res Function(_$PartnerReactionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? action = null,
    Object? physicalState = null,
    Object? mood = null,
  }) {
    return _then(_$PartnerReactionImpl(
      action: null == action
          ? _value.action
          : action // ignore: cast_nullable_to_non_nullable
              as String,
      physicalState: null == physicalState
          ? _value._physicalState
          : physicalState // ignore: cast_nullable_to_non_nullable
              as List<String>,
      mood: null == mood
          ? _value.mood
          : mood // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$PartnerReactionImpl implements _PartnerReaction {
  const _$PartnerReactionImpl(
      {required this.action,
      required final List<String> physicalState,
      required this.mood})
      : _physicalState = physicalState;

  factory _$PartnerReactionImpl.fromJson(Map<String, dynamic> json) =>
      _$$PartnerReactionImplFromJson(json);

  @override
  final String action;
  final List<String> _physicalState;
  @override
  List<String> get physicalState {
    if (_physicalState is EqualUnmodifiableListView) return _physicalState;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_physicalState);
  }

  @override
  final String mood;

  @override
  String toString() {
    return 'PartnerReaction(action: $action, physicalState: $physicalState, mood: $mood)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PartnerReactionImpl &&
            (identical(other.action, action) || other.action == action) &&
            const DeepCollectionEquality()
                .equals(other._physicalState, _physicalState) &&
            (identical(other.mood, mood) || other.mood == mood));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, action,
      const DeepCollectionEquality().hash(_physicalState), mood);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PartnerReactionImplCopyWith<_$PartnerReactionImpl> get copyWith =>
      __$$PartnerReactionImplCopyWithImpl<_$PartnerReactionImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$PartnerReactionImplToJson(
      this,
    );
  }
}

abstract class _PartnerReaction implements PartnerReaction {
  const factory _PartnerReaction(
      {required final String action,
      required final List<String> physicalState,
      required final String mood}) = _$PartnerReactionImpl;

  factory _PartnerReaction.fromJson(Map<String, dynamic> json) =
      _$PartnerReactionImpl.fromJson;

  @override
  String get action;
  @override
  List<String> get physicalState;
  @override
  String get mood;
  @override
  @JsonKey(ignore: true)
  _$$PartnerReactionImplCopyWith<_$PartnerReactionImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

SceneContext _$SceneContextFromJson(Map<String, dynamic> json) {
  return _SceneContext.fromJson(json);
}

/// @nodoc
mixin _$SceneContext {
  VisualDescriptor? get currentSituation => throw _privateConstructorUsedError;
  String get emotionalAtmosphere => throw _privateConstructorUsedError;
  String get location => throw _privateConstructorUsedError;
  String get timeOfDay => throw _privateConstructorUsedError;
  String get weather => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SceneContextCopyWith<SceneContext> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SceneContextCopyWith<$Res> {
  factory $SceneContextCopyWith(
          SceneContext value, $Res Function(SceneContext) then) =
      _$SceneContextCopyWithImpl<$Res, SceneContext>;
  @useResult
  $Res call(
      {VisualDescriptor? currentSituation,
      String emotionalAtmosphere,
      String location,
      String timeOfDay,
      String weather});

  $VisualDescriptorCopyWith<$Res>? get currentSituation;
}

/// @nodoc
class _$SceneContextCopyWithImpl<$Res, $Val extends SceneContext>
    implements $SceneContextCopyWith<$Res> {
  _$SceneContextCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? currentSituation = freezed,
    Object? emotionalAtmosphere = null,
    Object? location = null,
    Object? timeOfDay = null,
    Object? weather = null,
  }) {
    return _then(_value.copyWith(
      currentSituation: freezed == currentSituation
          ? _value.currentSituation
          : currentSituation // ignore: cast_nullable_to_non_nullable
              as VisualDescriptor?,
      emotionalAtmosphere: null == emotionalAtmosphere
          ? _value.emotionalAtmosphere
          : emotionalAtmosphere // ignore: cast_nullable_to_non_nullable
              as String,
      location: null == location
          ? _value.location
          : location // ignore: cast_nullable_to_non_nullable
              as String,
      timeOfDay: null == timeOfDay
          ? _value.timeOfDay
          : timeOfDay // ignore: cast_nullable_to_non_nullable
              as String,
      weather: null == weather
          ? _value.weather
          : weather // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $VisualDescriptorCopyWith<$Res>? get currentSituation {
    if (_value.currentSituation == null) {
      return null;
    }

    return $VisualDescriptorCopyWith<$Res>(_value.currentSituation!, (value) {
      return _then(_value.copyWith(currentSituation: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$SceneContextImplCopyWith<$Res>
    implements $SceneContextCopyWith<$Res> {
  factory _$$SceneContextImplCopyWith(
          _$SceneContextImpl value, $Res Function(_$SceneContextImpl) then) =
      __$$SceneContextImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {VisualDescriptor? currentSituation,
      String emotionalAtmosphere,
      String location,
      String timeOfDay,
      String weather});

  @override
  $VisualDescriptorCopyWith<$Res>? get currentSituation;
}

/// @nodoc
class __$$SceneContextImplCopyWithImpl<$Res>
    extends _$SceneContextCopyWithImpl<$Res, _$SceneContextImpl>
    implements _$$SceneContextImplCopyWith<$Res> {
  __$$SceneContextImplCopyWithImpl(
      _$SceneContextImpl _value, $Res Function(_$SceneContextImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? currentSituation = freezed,
    Object? emotionalAtmosphere = null,
    Object? location = null,
    Object? timeOfDay = null,
    Object? weather = null,
  }) {
    return _then(_$SceneContextImpl(
      currentSituation: freezed == currentSituation
          ? _value.currentSituation
          : currentSituation // ignore: cast_nullable_to_non_nullable
              as VisualDescriptor?,
      emotionalAtmosphere: null == emotionalAtmosphere
          ? _value.emotionalAtmosphere
          : emotionalAtmosphere // ignore: cast_nullable_to_non_nullable
              as String,
      location: null == location
          ? _value.location
          : location // ignore: cast_nullable_to_non_nullable
              as String,
      timeOfDay: null == timeOfDay
          ? _value.timeOfDay
          : timeOfDay // ignore: cast_nullable_to_non_nullable
              as String,
      weather: null == weather
          ? _value.weather
          : weather // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$SceneContextImpl implements _SceneContext {
  const _$SceneContextImpl(
      {this.currentSituation,
      required this.emotionalAtmosphere,
      required this.location,
      required this.timeOfDay,
      required this.weather});

  factory _$SceneContextImpl.fromJson(Map<String, dynamic> json) =>
      _$$SceneContextImplFromJson(json);

  @override
  final VisualDescriptor? currentSituation;
  @override
  final String emotionalAtmosphere;
  @override
  final String location;
  @override
  final String timeOfDay;
  @override
  final String weather;

  @override
  String toString() {
    return 'SceneContext(currentSituation: $currentSituation, emotionalAtmosphere: $emotionalAtmosphere, location: $location, timeOfDay: $timeOfDay, weather: $weather)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SceneContextImpl &&
            (identical(other.currentSituation, currentSituation) ||
                other.currentSituation == currentSituation) &&
            (identical(other.emotionalAtmosphere, emotionalAtmosphere) ||
                other.emotionalAtmosphere == emotionalAtmosphere) &&
            (identical(other.location, location) ||
                other.location == location) &&
            (identical(other.timeOfDay, timeOfDay) ||
                other.timeOfDay == timeOfDay) &&
            (identical(other.weather, weather) || other.weather == weather));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, currentSituation,
      emotionalAtmosphere, location, timeOfDay, weather);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SceneContextImplCopyWith<_$SceneContextImpl> get copyWith =>
      __$$SceneContextImplCopyWithImpl<_$SceneContextImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$SceneContextImplToJson(
      this,
    );
  }
}

abstract class _SceneContext implements SceneContext {
  const factory _SceneContext(
      {final VisualDescriptor? currentSituation,
      required final String emotionalAtmosphere,
      required final String location,
      required final String timeOfDay,
      required final String weather}) = _$SceneContextImpl;

  factory _SceneContext.fromJson(Map<String, dynamic> json) =
      _$SceneContextImpl.fromJson;

  @override
  VisualDescriptor? get currentSituation;
  @override
  String get emotionalAtmosphere;
  @override
  String get location;
  @override
  String get timeOfDay;
  @override
  String get weather;
  @override
  @JsonKey(ignore: true)
  _$$SceneContextImplCopyWith<_$SceneContextImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CharacterVisuals _$CharacterVisualsFromJson(Map<String, dynamic> json) {
  return _CharacterVisuals.fromJson(json);
}

/// @nodoc
mixin _$CharacterVisuals {
  PartnerVisuals get partner => throw _privateConstructorUsedError;
  UserVisuals get user => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CharacterVisualsCopyWith<CharacterVisuals> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CharacterVisualsCopyWith<$Res> {
  factory $CharacterVisualsCopyWith(
          CharacterVisuals value, $Res Function(CharacterVisuals) then) =
      _$CharacterVisualsCopyWithImpl<$Res, CharacterVisuals>;
  @useResult
  $Res call({PartnerVisuals partner, UserVisuals user});

  $PartnerVisualsCopyWith<$Res> get partner;
  $UserVisualsCopyWith<$Res> get user;
}

/// @nodoc
class _$CharacterVisualsCopyWithImpl<$Res, $Val extends CharacterVisuals>
    implements $CharacterVisualsCopyWith<$Res> {
  _$CharacterVisualsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? partner = null,
    Object? user = null,
  }) {
    return _then(_value.copyWith(
      partner: null == partner
          ? _value.partner
          : partner // ignore: cast_nullable_to_non_nullable
              as PartnerVisuals,
      user: null == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as UserVisuals,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $PartnerVisualsCopyWith<$Res> get partner {
    return $PartnerVisualsCopyWith<$Res>(_value.partner, (value) {
      return _then(_value.copyWith(partner: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $UserVisualsCopyWith<$Res> get user {
    return $UserVisualsCopyWith<$Res>(_value.user, (value) {
      return _then(_value.copyWith(user: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CharacterVisualsImplCopyWith<$Res>
    implements $CharacterVisualsCopyWith<$Res> {
  factory _$$CharacterVisualsImplCopyWith(_$CharacterVisualsImpl value,
          $Res Function(_$CharacterVisualsImpl) then) =
      __$$CharacterVisualsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({PartnerVisuals partner, UserVisuals user});

  @override
  $PartnerVisualsCopyWith<$Res> get partner;
  @override
  $UserVisualsCopyWith<$Res> get user;
}

/// @nodoc
class __$$CharacterVisualsImplCopyWithImpl<$Res>
    extends _$CharacterVisualsCopyWithImpl<$Res, _$CharacterVisualsImpl>
    implements _$$CharacterVisualsImplCopyWith<$Res> {
  __$$CharacterVisualsImplCopyWithImpl(_$CharacterVisualsImpl _value,
      $Res Function(_$CharacterVisualsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? partner = null,
    Object? user = null,
  }) {
    return _then(_$CharacterVisualsImpl(
      partner: null == partner
          ? _value.partner
          : partner // ignore: cast_nullable_to_non_nullable
              as PartnerVisuals,
      user: null == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as UserVisuals,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CharacterVisualsImpl implements _CharacterVisuals {
  const _$CharacterVisualsImpl({required this.partner, required this.user});

  factory _$CharacterVisualsImpl.fromJson(Map<String, dynamic> json) =>
      _$$CharacterVisualsImplFromJson(json);

  @override
  final PartnerVisuals partner;
  @override
  final UserVisuals user;

  @override
  String toString() {
    return 'CharacterVisuals(partner: $partner, user: $user)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CharacterVisualsImpl &&
            (identical(other.partner, partner) || other.partner == partner) &&
            (identical(other.user, user) || other.user == user));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, partner, user);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CharacterVisualsImplCopyWith<_$CharacterVisualsImpl> get copyWith =>
      __$$CharacterVisualsImplCopyWithImpl<_$CharacterVisualsImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CharacterVisualsImplToJson(
      this,
    );
  }
}

abstract class _CharacterVisuals implements CharacterVisuals {
  const factory _CharacterVisuals(
      {required final PartnerVisuals partner,
      required final UserVisuals user}) = _$CharacterVisualsImpl;

  factory _CharacterVisuals.fromJson(Map<String, dynamic> json) =
      _$CharacterVisualsImpl.fromJson;

  @override
  PartnerVisuals get partner;
  @override
  UserVisuals get user;
  @override
  @JsonKey(ignore: true)
  _$$CharacterVisualsImplCopyWith<_$CharacterVisualsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

PartnerVisuals _$PartnerVisualsFromJson(Map<String, dynamic> json) {
  return _PartnerVisuals.fromJson(json);
}

/// @nodoc
mixin _$PartnerVisuals {
  VisualDescriptor get face => throw _privateConstructorUsedError;
  VisualDescriptor get hairstyle => throw _privateConstructorUsedError;
  VisualDescriptor get body => throw _privateConstructorUsedError;
  VisualDescriptor get accessories => throw _privateConstructorUsedError;
  VisualDescriptor get outfit => throw _privateConstructorUsedError;
  VisualDescriptor? get nsfwOutfit => throw _privateConstructorUsedError;
  bool get isNSFWAllowed => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PartnerVisualsCopyWith<PartnerVisuals> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PartnerVisualsCopyWith<$Res> {
  factory $PartnerVisualsCopyWith(
          PartnerVisuals value, $Res Function(PartnerVisuals) then) =
      _$PartnerVisualsCopyWithImpl<$Res, PartnerVisuals>;
  @useResult
  $Res call(
      {VisualDescriptor face,
      VisualDescriptor hairstyle,
      VisualDescriptor body,
      VisualDescriptor accessories,
      VisualDescriptor outfit,
      VisualDescriptor? nsfwOutfit,
      bool isNSFWAllowed});

  $VisualDescriptorCopyWith<$Res> get face;
  $VisualDescriptorCopyWith<$Res> get hairstyle;
  $VisualDescriptorCopyWith<$Res> get body;
  $VisualDescriptorCopyWith<$Res> get accessories;
  $VisualDescriptorCopyWith<$Res> get outfit;
  $VisualDescriptorCopyWith<$Res>? get nsfwOutfit;
}

/// @nodoc
class _$PartnerVisualsCopyWithImpl<$Res, $Val extends PartnerVisuals>
    implements $PartnerVisualsCopyWith<$Res> {
  _$PartnerVisualsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? face = null,
    Object? hairstyle = null,
    Object? body = null,
    Object? accessories = null,
    Object? outfit = null,
    Object? nsfwOutfit = freezed,
    Object? isNSFWAllowed = null,
  }) {
    return _then(_value.copyWith(
      face: null == face
          ? _value.face
          : face // ignore: cast_nullable_to_non_nullable
              as VisualDescriptor,
      hairstyle: null == hairstyle
          ? _value.hairstyle
          : hairstyle // ignore: cast_nullable_to_non_nullable
              as VisualDescriptor,
      body: null == body
          ? _value.body
          : body // ignore: cast_nullable_to_non_nullable
              as VisualDescriptor,
      accessories: null == accessories
          ? _value.accessories
          : accessories // ignore: cast_nullable_to_non_nullable
              as VisualDescriptor,
      outfit: null == outfit
          ? _value.outfit
          : outfit // ignore: cast_nullable_to_non_nullable
              as VisualDescriptor,
      nsfwOutfit: freezed == nsfwOutfit
          ? _value.nsfwOutfit
          : nsfwOutfit // ignore: cast_nullable_to_non_nullable
              as VisualDescriptor?,
      isNSFWAllowed: null == isNSFWAllowed
          ? _value.isNSFWAllowed
          : isNSFWAllowed // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $VisualDescriptorCopyWith<$Res> get face {
    return $VisualDescriptorCopyWith<$Res>(_value.face, (value) {
      return _then(_value.copyWith(face: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $VisualDescriptorCopyWith<$Res> get hairstyle {
    return $VisualDescriptorCopyWith<$Res>(_value.hairstyle, (value) {
      return _then(_value.copyWith(hairstyle: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $VisualDescriptorCopyWith<$Res> get body {
    return $VisualDescriptorCopyWith<$Res>(_value.body, (value) {
      return _then(_value.copyWith(body: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $VisualDescriptorCopyWith<$Res> get accessories {
    return $VisualDescriptorCopyWith<$Res>(_value.accessories, (value) {
      return _then(_value.copyWith(accessories: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $VisualDescriptorCopyWith<$Res> get outfit {
    return $VisualDescriptorCopyWith<$Res>(_value.outfit, (value) {
      return _then(_value.copyWith(outfit: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $VisualDescriptorCopyWith<$Res>? get nsfwOutfit {
    if (_value.nsfwOutfit == null) {
      return null;
    }

    return $VisualDescriptorCopyWith<$Res>(_value.nsfwOutfit!, (value) {
      return _then(_value.copyWith(nsfwOutfit: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$PartnerVisualsImplCopyWith<$Res>
    implements $PartnerVisualsCopyWith<$Res> {
  factory _$$PartnerVisualsImplCopyWith(_$PartnerVisualsImpl value,
          $Res Function(_$PartnerVisualsImpl) then) =
      __$$PartnerVisualsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {VisualDescriptor face,
      VisualDescriptor hairstyle,
      VisualDescriptor body,
      VisualDescriptor accessories,
      VisualDescriptor outfit,
      VisualDescriptor? nsfwOutfit,
      bool isNSFWAllowed});

  @override
  $VisualDescriptorCopyWith<$Res> get face;
  @override
  $VisualDescriptorCopyWith<$Res> get hairstyle;
  @override
  $VisualDescriptorCopyWith<$Res> get body;
  @override
  $VisualDescriptorCopyWith<$Res> get accessories;
  @override
  $VisualDescriptorCopyWith<$Res> get outfit;
  @override
  $VisualDescriptorCopyWith<$Res>? get nsfwOutfit;
}

/// @nodoc
class __$$PartnerVisualsImplCopyWithImpl<$Res>
    extends _$PartnerVisualsCopyWithImpl<$Res, _$PartnerVisualsImpl>
    implements _$$PartnerVisualsImplCopyWith<$Res> {
  __$$PartnerVisualsImplCopyWithImpl(
      _$PartnerVisualsImpl _value, $Res Function(_$PartnerVisualsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? face = null,
    Object? hairstyle = null,
    Object? body = null,
    Object? accessories = null,
    Object? outfit = null,
    Object? nsfwOutfit = freezed,
    Object? isNSFWAllowed = null,
  }) {
    return _then(_$PartnerVisualsImpl(
      face: null == face
          ? _value.face
          : face // ignore: cast_nullable_to_non_nullable
              as VisualDescriptor,
      hairstyle: null == hairstyle
          ? _value.hairstyle
          : hairstyle // ignore: cast_nullable_to_non_nullable
              as VisualDescriptor,
      body: null == body
          ? _value.body
          : body // ignore: cast_nullable_to_non_nullable
              as VisualDescriptor,
      accessories: null == accessories
          ? _value.accessories
          : accessories // ignore: cast_nullable_to_non_nullable
              as VisualDescriptor,
      outfit: null == outfit
          ? _value.outfit
          : outfit // ignore: cast_nullable_to_non_nullable
              as VisualDescriptor,
      nsfwOutfit: freezed == nsfwOutfit
          ? _value.nsfwOutfit
          : nsfwOutfit // ignore: cast_nullable_to_non_nullable
              as VisualDescriptor?,
      isNSFWAllowed: null == isNSFWAllowed
          ? _value.isNSFWAllowed
          : isNSFWAllowed // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$PartnerVisualsImpl implements _PartnerVisuals {
  const _$PartnerVisualsImpl(
      {required this.face,
      required this.hairstyle,
      required this.body,
      required this.accessories,
      required this.outfit,
      this.nsfwOutfit,
      this.isNSFWAllowed = false});

  factory _$PartnerVisualsImpl.fromJson(Map<String, dynamic> json) =>
      _$$PartnerVisualsImplFromJson(json);

  @override
  final VisualDescriptor face;
  @override
  final VisualDescriptor hairstyle;
  @override
  final VisualDescriptor body;
  @override
  final VisualDescriptor accessories;
  @override
  final VisualDescriptor outfit;
  @override
  final VisualDescriptor? nsfwOutfit;
  @override
  @JsonKey()
  final bool isNSFWAllowed;

  @override
  String toString() {
    return 'PartnerVisuals(face: $face, hairstyle: $hairstyle, body: $body, accessories: $accessories, outfit: $outfit, nsfwOutfit: $nsfwOutfit, isNSFWAllowed: $isNSFWAllowed)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PartnerVisualsImpl &&
            (identical(other.face, face) || other.face == face) &&
            (identical(other.hairstyle, hairstyle) ||
                other.hairstyle == hairstyle) &&
            (identical(other.body, body) || other.body == body) &&
            (identical(other.accessories, accessories) ||
                other.accessories == accessories) &&
            (identical(other.outfit, outfit) || other.outfit == outfit) &&
            (identical(other.nsfwOutfit, nsfwOutfit) ||
                other.nsfwOutfit == nsfwOutfit) &&
            (identical(other.isNSFWAllowed, isNSFWAllowed) ||
                other.isNSFWAllowed == isNSFWAllowed));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, face, hairstyle, body,
      accessories, outfit, nsfwOutfit, isNSFWAllowed);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PartnerVisualsImplCopyWith<_$PartnerVisualsImpl> get copyWith =>
      __$$PartnerVisualsImplCopyWithImpl<_$PartnerVisualsImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$PartnerVisualsImplToJson(
      this,
    );
  }
}

abstract class _PartnerVisuals implements PartnerVisuals {
  const factory _PartnerVisuals(
      {required final VisualDescriptor face,
      required final VisualDescriptor hairstyle,
      required final VisualDescriptor body,
      required final VisualDescriptor accessories,
      required final VisualDescriptor outfit,
      final VisualDescriptor? nsfwOutfit,
      final bool isNSFWAllowed}) = _$PartnerVisualsImpl;

  factory _PartnerVisuals.fromJson(Map<String, dynamic> json) =
      _$PartnerVisualsImpl.fromJson;

  @override
  VisualDescriptor get face;
  @override
  VisualDescriptor get hairstyle;
  @override
  VisualDescriptor get body;
  @override
  VisualDescriptor get accessories;
  @override
  VisualDescriptor get outfit;
  @override
  VisualDescriptor? get nsfwOutfit;
  @override
  bool get isNSFWAllowed;
  @override
  @JsonKey(ignore: true)
  _$$PartnerVisualsImplCopyWith<_$PartnerVisualsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

UserVisuals _$UserVisualsFromJson(Map<String, dynamic> json) {
  return _UserVisuals.fromJson(json);
}

/// @nodoc
mixin _$UserVisuals {
  VisualDescriptor get face => throw _privateConstructorUsedError;
  VisualDescriptor get hairstyle => throw _privateConstructorUsedError;
  VisualDescriptor get body => throw _privateConstructorUsedError;
  VisualDescriptor get accessories => throw _privateConstructorUsedError;
  VisualDescriptor get outfit => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $UserVisualsCopyWith<UserVisuals> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserVisualsCopyWith<$Res> {
  factory $UserVisualsCopyWith(
          UserVisuals value, $Res Function(UserVisuals) then) =
      _$UserVisualsCopyWithImpl<$Res, UserVisuals>;
  @useResult
  $Res call(
      {VisualDescriptor face,
      VisualDescriptor hairstyle,
      VisualDescriptor body,
      VisualDescriptor accessories,
      VisualDescriptor outfit});

  $VisualDescriptorCopyWith<$Res> get face;
  $VisualDescriptorCopyWith<$Res> get hairstyle;
  $VisualDescriptorCopyWith<$Res> get body;
  $VisualDescriptorCopyWith<$Res> get accessories;
  $VisualDescriptorCopyWith<$Res> get outfit;
}

/// @nodoc
class _$UserVisualsCopyWithImpl<$Res, $Val extends UserVisuals>
    implements $UserVisualsCopyWith<$Res> {
  _$UserVisualsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? face = null,
    Object? hairstyle = null,
    Object? body = null,
    Object? accessories = null,
    Object? outfit = null,
  }) {
    return _then(_value.copyWith(
      face: null == face
          ? _value.face
          : face // ignore: cast_nullable_to_non_nullable
              as VisualDescriptor,
      hairstyle: null == hairstyle
          ? _value.hairstyle
          : hairstyle // ignore: cast_nullable_to_non_nullable
              as VisualDescriptor,
      body: null == body
          ? _value.body
          : body // ignore: cast_nullable_to_non_nullable
              as VisualDescriptor,
      accessories: null == accessories
          ? _value.accessories
          : accessories // ignore: cast_nullable_to_non_nullable
              as VisualDescriptor,
      outfit: null == outfit
          ? _value.outfit
          : outfit // ignore: cast_nullable_to_non_nullable
              as VisualDescriptor,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $VisualDescriptorCopyWith<$Res> get face {
    return $VisualDescriptorCopyWith<$Res>(_value.face, (value) {
      return _then(_value.copyWith(face: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $VisualDescriptorCopyWith<$Res> get hairstyle {
    return $VisualDescriptorCopyWith<$Res>(_value.hairstyle, (value) {
      return _then(_value.copyWith(hairstyle: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $VisualDescriptorCopyWith<$Res> get body {
    return $VisualDescriptorCopyWith<$Res>(_value.body, (value) {
      return _then(_value.copyWith(body: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $VisualDescriptorCopyWith<$Res> get accessories {
    return $VisualDescriptorCopyWith<$Res>(_value.accessories, (value) {
      return _then(_value.copyWith(accessories: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $VisualDescriptorCopyWith<$Res> get outfit {
    return $VisualDescriptorCopyWith<$Res>(_value.outfit, (value) {
      return _then(_value.copyWith(outfit: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$UserVisualsImplCopyWith<$Res>
    implements $UserVisualsCopyWith<$Res> {
  factory _$$UserVisualsImplCopyWith(
          _$UserVisualsImpl value, $Res Function(_$UserVisualsImpl) then) =
      __$$UserVisualsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {VisualDescriptor face,
      VisualDescriptor hairstyle,
      VisualDescriptor body,
      VisualDescriptor accessories,
      VisualDescriptor outfit});

  @override
  $VisualDescriptorCopyWith<$Res> get face;
  @override
  $VisualDescriptorCopyWith<$Res> get hairstyle;
  @override
  $VisualDescriptorCopyWith<$Res> get body;
  @override
  $VisualDescriptorCopyWith<$Res> get accessories;
  @override
  $VisualDescriptorCopyWith<$Res> get outfit;
}

/// @nodoc
class __$$UserVisualsImplCopyWithImpl<$Res>
    extends _$UserVisualsCopyWithImpl<$Res, _$UserVisualsImpl>
    implements _$$UserVisualsImplCopyWith<$Res> {
  __$$UserVisualsImplCopyWithImpl(
      _$UserVisualsImpl _value, $Res Function(_$UserVisualsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? face = null,
    Object? hairstyle = null,
    Object? body = null,
    Object? accessories = null,
    Object? outfit = null,
  }) {
    return _then(_$UserVisualsImpl(
      face: null == face
          ? _value.face
          : face // ignore: cast_nullable_to_non_nullable
              as VisualDescriptor,
      hairstyle: null == hairstyle
          ? _value.hairstyle
          : hairstyle // ignore: cast_nullable_to_non_nullable
              as VisualDescriptor,
      body: null == body
          ? _value.body
          : body // ignore: cast_nullable_to_non_nullable
              as VisualDescriptor,
      accessories: null == accessories
          ? _value.accessories
          : accessories // ignore: cast_nullable_to_non_nullable
              as VisualDescriptor,
      outfit: null == outfit
          ? _value.outfit
          : outfit // ignore: cast_nullable_to_non_nullable
              as VisualDescriptor,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UserVisualsImpl implements _UserVisuals {
  const _$UserVisualsImpl(
      {required this.face,
      required this.hairstyle,
      required this.body,
      required this.accessories,
      required this.outfit});

  factory _$UserVisualsImpl.fromJson(Map<String, dynamic> json) =>
      _$$UserVisualsImplFromJson(json);

  @override
  final VisualDescriptor face;
  @override
  final VisualDescriptor hairstyle;
  @override
  final VisualDescriptor body;
  @override
  final VisualDescriptor accessories;
  @override
  final VisualDescriptor outfit;

  @override
  String toString() {
    return 'UserVisuals(face: $face, hairstyle: $hairstyle, body: $body, accessories: $accessories, outfit: $outfit)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserVisualsImpl &&
            (identical(other.face, face) || other.face == face) &&
            (identical(other.hairstyle, hairstyle) ||
                other.hairstyle == hairstyle) &&
            (identical(other.body, body) || other.body == body) &&
            (identical(other.accessories, accessories) ||
                other.accessories == accessories) &&
            (identical(other.outfit, outfit) || other.outfit == outfit));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, face, hairstyle, body, accessories, outfit);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserVisualsImplCopyWith<_$UserVisualsImpl> get copyWith =>
      __$$UserVisualsImplCopyWithImpl<_$UserVisualsImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$UserVisualsImplToJson(
      this,
    );
  }
}

abstract class _UserVisuals implements UserVisuals {
  const factory _UserVisuals(
      {required final VisualDescriptor face,
      required final VisualDescriptor hairstyle,
      required final VisualDescriptor body,
      required final VisualDescriptor accessories,
      required final VisualDescriptor outfit}) = _$UserVisualsImpl;

  factory _UserVisuals.fromJson(Map<String, dynamic> json) =
      _$UserVisualsImpl.fromJson;

  @override
  VisualDescriptor get face;
  @override
  VisualDescriptor get hairstyle;
  @override
  VisualDescriptor get body;
  @override
  VisualDescriptor get accessories;
  @override
  VisualDescriptor get outfit;
  @override
  @JsonKey(ignore: true)
  _$$UserVisualsImplCopyWith<_$UserVisualsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
